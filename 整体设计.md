#整体的设计

整个WebServer分为5个模块：WebServer、EventLoop、HttpConn、Thread、Timer、Log

* WebServer：负责连接的建立与断开，往线程池任务队列派发任务。
* EventLoop： WebServer的事件循环，同时分发事件，而且这里事件的实现使用函数对象（std::function)，通过形式可以存储，复制和调用任何可调用的目标，让这里由很强的可扩展性，可以用于任何可能的事件
* HttpConn： 负责处理用户请求，分为内部由HttpRequest（解析请求）和 HttpResponse（填充响应）以及一个封装过的Socket（保存用户连接信息）
* Thread： 线程池，里面包括一个保存thread的vector容器以及一个任务队列，线程经过封装通过tid唯一的标识每一个线程，任务队列中的每个任务同样使用使用函数对象（std::function)。
* Timer： 定时器的实现采用时间轮实现，这里的定时器采用的是boost::circular_buffe实现，所有同一时间的用户连接全部统一的放在一个bucket中，当时间到期轮子内的全部定时器析构，不需要一个一个关闭用户连接，定时器析构中关闭用户连接
* Log：Log的实现非为Logging（日志库）和AsyncLogging（异步日志）以及LogFile（储存文件），前端通过Logging产生日志，在多线程中AsyncLogging负责日志的收集，最后通过LogFile保存日志。Log的实现模仿C++stream风格，重载了<<

整个程序的运行逻辑是WebServer开始往EveLoop上注册事件，同时初始化完线程池、定时器、日志，主线程EventLoop开启事件循环，每检测到事件，通过在上面注册回调函数执行不同的工作完成任务的分发，在结束完任务后，EventLoop会开始安全的处理从线程中发送过来任务，最后处理定时事件

## WebServer
WebServer主要是初始化和通过往EvetLoop上面注册事件来工作，而其中最重要的就是负责连接的建立与断开，因为连接的建立是在主线程完成的所有包括accept，用户数据的初始化以及定时器的添加都是线程安全的。
最为麻烦的就是连接的断开了，因为连接的断开可能出现的情况很多，同时一般处理连接都是在读到零时断开用户连接，而这发生在工作线程中，这必然导致线程不安全的情况，因为连接的断开要访问共享数据，最容易的解决办法就是通过加锁来保证线程安全，但是这一加锁可能会严重影响效率，因为这会导致所有线程包括主线程都在竞争全局的大锁，这样前面的接受连接，访问用户数据都得加锁锁，这会使得多线程直接退化成单线程。
所以为了解决连接断开的问题，我首先通过EPOLLRDHUP，当当主线程监听到对端挂起时，在分发任务过程，主线程这时会先完成注册的连接断开事件，这时用户数据析构，连接断开，不会在把事件分发给可读事件，让线程去读零，这样就在主线程解决了线程安全的问题
然而这还不够因为工作线程这时依然有可能读到0出现连接断开的情况，为什么呢？因为当EventLoop监听到事件时，首先是把可读或可写事件放在线程池的工作队列中，一旦面对高并发短连接的情况，很容易导致线程处理不过来，对方已经关闭连接了，这时候当线程开始从线程池上拿到对端关闭的连接就会导致读到零而在线程中关闭连接造成线程安全的问题。
在这这里我用了加锁以外的在muduo网络库中学习到的另一种方式在主线程关闭连接，通过另一任务队列，线程会把可能产生安全问题的任务送到这个队列中，由主线程调用，这样就把关闭连接转移到主线程上去
虽然同样会线程中同样会竞争一个锁在加入任务队列的时候，但是这只发生在工作线程并且只有在工作线程可能读到零的情况（大部分还是直接通过RDHUP事件直接关闭），把对性能降到最低。


